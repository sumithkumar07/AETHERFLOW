from typing import Dict, List, Optional, Any
import asyncio
import json
from datetime import datetime
import re

class SmartDocumentationEngine:
    """AI service that writes documentation as you code"""
    
    def __init__(self, db_wrapper):
        self.db = db_wrapper
        self.documentation_cache = {}
        self.code_analysis_cache = {}
    
    async def initialize(self):
        """Initialize the smart documentation service"""
        try:
            self.documentation_templates = await self._load_documentation_templates()
            return True
        except Exception as e:
            print(f"Smart Documentation initialization error: {e}")
            return False
    
    async def generate_realtime_documentation(self, code: str, file_type: str, context: Dict[str, Any]) -> Dict[str, Any]:
        """Generate documentation in real-time as user codes"""
        try:
            analysis = await self._analyze_code_structure(code, file_type)
            
            documentation = {
                "timestamp": datetime.utcnow().isoformat(),
                "file_type": file_type,
                "auto_comments": await self._generate_inline_comments(code, file_type),
                "function_docs": await self._generate_function_documentation(analysis.get("functions", [])),
                "api_docs": await self._generate_api_documentation(analysis.get("endpoints", [])),
                "readme_sections": await self._generate_readme_sections(analysis, context),
                "complexity_score": analysis.get("complexity_score", 0),
                "documentation_coverage": await self._calculate_documentation_coverage(code, file_type)
            }
            
            return documentation
        except Exception as e:
            return {"error": str(e), "timestamp": datetime.utcnow().isoformat()}
    
    async def auto_generate_readme(self, project_data: Dict[str, Any]) -> str:
        """Auto-generate comprehensive README file"""
        try:
            readme_content = f"""# {project_data.get('name', 'Project')}

## Description
{project_data.get('description', 'AI-generated project description based on code analysis.')}

## Installation

```bash
# Clone the repository
git clone {project_data.get('repository_url', 'your-repo-url')}

# Navigate to project directory
cd {project_data.get('name', 'project-directory')}

# Install dependencies
{await self._generate_install_commands(project_data)}
```

## Usage

{await self._generate_usage_examples(project_data)}

## API Documentation

{await self._generate_api_overview(project_data)}

## Features

{await self._generate_features_list(project_data)}

## Configuration

{await self._generate_configuration_docs(project_data)}

## Contributing

1. Fork the repository
2. Create a feature branch: `git checkout -b feature-name`
3. Commit your changes: `git commit -am 'Add some feature'`
4. Push to the branch: `git push origin feature-name`
5. Submit a pull request

## License

{project_data.get('license', 'MIT License')}

---
*This README was auto-generated by AI Tempo's Smart Documentation Engine*
"""
            return readme_content
        except Exception as e:
            return f"Error generating README: {str(e)}"
    
    async def generate_api_documentation(self, endpoints: List[Dict[str, Any]]) -> str:
        """Generate comprehensive API documentation"""
        try:
            api_docs = """# API Documentation

## Overview
This API provides endpoints for managing and interacting with the application.

## Base URL
```
{base_url}
```

## Authentication
{auth_info}

## Endpoints

"""
            
            for endpoint in endpoints:
                api_docs += f"""### {endpoint.get('method', 'GET')} {endpoint.get('path', '/')}

**Description:** {endpoint.get('description', 'No description available')}

**Parameters:**
{await self._format_parameters(endpoint.get('parameters', []))}

**Response:**
```json
{json.dumps(endpoint.get('response_example', {}), indent=2)}
```

**Example Request:**
```bash
curl -X {endpoint.get('method', 'GET')} \\
  {endpoint.get('path', '/')} \\
  -H "Content-Type: application/json" \\
  -d '{json.dumps(endpoint.get('request_example', {}))}'
```

---

"""
            
            return api_docs
        except Exception as e:
            return f"Error generating API documentation: {str(e)}"
    
    async def suggest_inline_comments(self, code: str, file_type: str) -> List[Dict[str, Any]]:
        """Suggest inline comments for complex code sections"""
        try:
            suggestions = []
            lines = code.split('\n')
            
            for i, line in enumerate(lines):
                if self._is_complex_line(line, file_type):
                    comment = await self._generate_comment_for_line(line, file_type)
                    suggestions.append({
                        "line_number": i + 1,
                        "original_line": line,
                        "suggested_comment": comment,
                        "complexity_reason": await self._explain_complexity(line, file_type)
                    })
            
            return suggestions
        except Exception as e:
            return [{"error": str(e)}]
    
    async def generate_changelog(self, project_history: List[Dict[str, Any]]) -> str:
        """Auto-generate changelog from project history"""
        try:
            changelog = """# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

"""
            
            # Group changes by version
            versions = self._group_changes_by_version(project_history)
            
            for version, changes in versions.items():
                changelog += f"""## [{version}] - {changes.get('date', 'Unknown')}

### Added
{self._format_changes(changes.get('added', []))}

### Changed
{self._format_changes(changes.get('changed', []))}

### Fixed
{self._format_changes(changes.get('fixed', []))}

### Removed
{self._format_changes(changes.get('removed', []))}

"""
            
            return changelog
        except Exception as e:
            return f"Error generating changelog: {str(e)}"
    
    async def _analyze_code_structure(self, code: str, file_type: str) -> Dict[str, Any]:
        """Analyze code structure to extract documentable elements"""
        analysis = {
            "functions": [],
            "classes": [],
            "endpoints": [],
            "complexity_score": 0
        }
        
        if file_type in ['javascript', 'typescript', 'jsx', 'tsx']:
            analysis["functions"] = self._extract_js_functions(code)
            analysis["endpoints"] = self._extract_api_endpoints(code)
        elif file_type in ['python', 'py']:
            analysis["functions"] = self._extract_python_functions(code)
            analysis["classes"] = self._extract_python_classes(code)
        
        analysis["complexity_score"] = self._calculate_complexity_score(code)
        
        return analysis
    
    async def _generate_inline_comments(self, code: str, file_type: str) -> List[Dict[str, Any]]:
        """Generate inline comments for complex code sections"""
        comments = []
        lines = code.split('\n')
        
        for i, line in enumerate(lines):
            if self._needs_comment(line, file_type):
                comment = await self._create_explanatory_comment(line, file_type)
                comments.append({
                    "line": i + 1,
                    "comment": comment
                })
        
        return comments
    
    async def _generate_function_documentation(self, functions: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate documentation for functions"""
        docs = []
        
        for func in functions:
            doc = {
                "name": func.get("name"),
                "description": await self._generate_function_description(func),
                "parameters": await self._document_parameters(func.get("parameters", [])),
                "returns": await self._document_return_value(func),
                "examples": await self._generate_usage_examples_for_function(func)
            }
            docs.append(doc)
        
        return docs
    
    async def _generate_api_documentation(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Generate API documentation for endpoints"""
        api_docs = []
        
        for endpoint in endpoints:
            doc = {
                "method": endpoint.get("method"),
                "path": endpoint.get("path"),
                "description": await self._generate_endpoint_description(endpoint),
                "parameters": endpoint.get("parameters", []),
                "response": await self._generate_response_schema(endpoint)
            }
            api_docs.append(doc)
        
        return api_docs
    
    async def _generate_readme_sections(self, analysis: Dict[str, Any], context: Dict[str, Any]) -> Dict[str, str]:
        """Generate sections for README file"""
        return {
            "description": await self._generate_project_description(analysis, context),
            "installation": await self._generate_installation_instructions(context),
            "usage": await self._generate_usage_instructions(analysis),
            "api": await self._generate_api_overview(context)
        }
    
    async def _calculate_documentation_coverage(self, code: str, file_type: str) -> float:
        """Calculate documentation coverage percentage"""
        total_documentable_items = self._count_documentable_items(code, file_type)
        documented_items = self._count_documented_items(code, file_type)
        
        if total_documentable_items == 0:
            return 100.0
        
        return (documented_items / total_documentable_items) * 100
    
    async def _load_documentation_templates(self) -> Dict[str, str]:
        """Load documentation templates"""
        return {
            "function": "/**\n * {description}\n * @param {type} {name} - {description}\n * @returns {type} {description}\n */",
            "class": "/**\n * {description}\n * @class {name}\n */",
            "api": "/**\n * {description}\n * @route {method} {path}\n * @param {type} {name} - {description}\n * @returns {type} {description}\n */"
        }
    
    def _extract_js_functions(self, code: str) -> List[Dict[str, Any]]:
        """Extract JavaScript/TypeScript functions"""
        # Simplified function extraction
        functions = []
        function_pattern = r'function\s+(\w+)\s*\([^)]*\)|const\s+(\w+)\s*=\s*\([^)]*\)\s*=>'
        matches = re.finditer(function_pattern, code)
        
        for match in matches:
            func_name = match.group(1) or match.group(2)
            functions.append({
                "name": func_name,
                "parameters": [],
                "type": "function"
            })
        
        return functions
    
    def _extract_python_functions(self, code: str) -> List[Dict[str, Any]]:
        """Extract Python functions"""
        functions = []
        function_pattern = r'def\s+(\w+)\s*\([^)]*\):'
        matches = re.finditer(function_pattern, code)
        
        for match in matches:
            functions.append({
                "name": match.group(1),
                "parameters": [],
                "type": "function"
            })
        
        return functions
    
    def _extract_python_classes(self, code: str) -> List[Dict[str, Any]]:
        """Extract Python classes"""
        classes = []
        class_pattern = r'class\s+(\w+)(?:\([^)]*\))?:'
        matches = re.finditer(class_pattern, code)
        
        for match in matches:
            classes.append({
                "name": match.group(1),
                "type": "class"
            })
        
        return classes
    
    def _extract_api_endpoints(self, code: str) -> List[Dict[str, Any]]:
        """Extract API endpoints from code"""
        endpoints = []
        # Simplified endpoint extraction for FastAPI/Express patterns
        endpoint_pattern = r'@app\.(get|post|put|delete|patch)\(["\']([^"\']+)["\']'
        matches = re.finditer(endpoint_pattern, code)
        
        for match in matches:
            endpoints.append({
                "method": match.group(1).upper(),
                "path": match.group(2),
                "parameters": []
            })
        
        return endpoints
    
    def _is_complex_line(self, line: str, file_type: str) -> bool:
        """Check if a line is complex enough to need a comment"""
        # Simplified complexity check
        complex_patterns = [
            r'\.filter\(.*\)\.map\(.*\)',  # Chained array methods
            r'async.*await.*await',        # Multiple awaits
            r'if.*and.*or',               # Complex conditionals
            r'for.*in.*if'                # Complex loops
        ]
        
        return any(re.search(pattern, line) for pattern in complex_patterns)
    
    def _needs_comment(self, line: str, file_type: str) -> bool:
        """Check if a line needs a comment"""
        return self._is_complex_line(line, file_type)
    
    def _calculate_complexity_score(self, code: str) -> int:
        """Calculate code complexity score"""
        # Simplified complexity calculation
        lines = len(code.split('\n'))
        if lines < 50:
            return 1
        elif lines < 200:
            return 2
        else:
            return 3
    
    def _count_documentable_items(self, code: str, file_type: str) -> int:
        """Count items that should be documented"""
        # Simplified count
        function_count = len(re.findall(r'function|def\s+\w+|const\s+\w+\s*=', code))
        class_count = len(re.findall(r'class\s+\w+', code))
        return function_count + class_count
    
    def _count_documented_items(self, code: str, file_type: str) -> int:
        """Count items that are already documented"""
        # Simplified count
        comment_count = len(re.findall(r'/\*\*|"""|\#\s*\w+', code))
        return comment_count
    
    def _group_changes_by_version(self, history: List[Dict[str, Any]]) -> Dict[str, Dict[str, Any]]:
        """Group changes by version"""
        return {
            "1.0.0": {
                "date": "2025-01-01",
                "added": ["Initial release"],
                "changed": [],
                "fixed": [],
                "removed": []
            }
        }
    
    def _format_changes(self, changes: List[str]) -> str:
        """Format changes for changelog"""
        if not changes:
            return "- No changes"
        return "\n".join([f"- {change}" for change in changes])
    
    async def _generate_install_commands(self, project_data: Dict[str, Any]) -> str:
        """Generate installation commands based on project type"""
        tech_stack = project_data.get('tech_stack', [])
        
        if 'npm' in tech_stack or 'node' in tech_stack:
            return "npm install"
        elif 'yarn' in tech_stack:
            return "yarn install"
        elif 'python' in tech_stack:
            return "pip install -r requirements.txt"
        else:
            return "# Follow project-specific installation instructions"
    
    async def _generate_usage_examples(self, project_data: Dict[str, Any]) -> str:
        """Generate usage examples"""
        return """```javascript
// Example usage
import { ProjectName } from './src/index.js'

const app = new ProjectName()
app.start()
```"""
    
    async def _generate_features_list(self, project_data: Dict[str, Any]) -> str:
        """Generate features list"""
        return """- ✨ AI-powered development
- 🚀 Real-time collaboration
- 📊 Smart analytics
- 🔍 Global search
- 🎯 Intelligent recommendations"""
    
    async def _generate_configuration_docs(self, project_data: Dict[str, Any]) -> str:
        """Generate configuration documentation"""
        return """Create a `.env` file in the root directory:

```env
NODE_ENV=development
PORT=3000
DATABASE_URL=your_database_url
API_KEY=your_api_key
```"""
    
    async def _generate_api_overview(self, project_data: Dict[str, Any]) -> str:
        """Generate API overview"""
        return """## API Endpoints

### Authentication
- `POST /api/auth/login` - User login
- `POST /api/auth/register` - User registration

### Projects
- `GET /api/projects` - List all projects
- `POST /api/projects` - Create new project
- `GET /api/projects/:id` - Get project details

For detailed API documentation, see [API.md](./API.md)"""
    
    async def _generate_comment_for_line(self, line: str, file_type: str) -> str:
        """Generate explanatory comment for a line"""
        return f"// Complex operation: {line.strip()}"
    
    async def _explain_complexity(self, line: str, file_type: str) -> str:
        """Explain why a line is complex"""
        return "This line contains multiple operations that may benefit from explanation"
    
    async def _create_explanatory_comment(self, line: str, file_type: str) -> str:
        """Create explanatory comment"""
        return f"// {line.strip()}"
    
    async def _generate_function_description(self, func: Dict[str, Any]) -> str:
        """Generate function description"""
        return f"Function {func.get('name')} performs specific operations"
    
    async def _document_parameters(self, parameters: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Document function parameters"""
        return [{"name": param.get("name"), "type": "any", "description": "Parameter description"} for param in parameters]
    
    async def _document_return_value(self, func: Dict[str, Any]) -> Dict[str, str]:
        """Document return value"""
        return {"type": "any", "description": "Return value description"}
    
    async def _generate_usage_examples_for_function(self, func: Dict[str, Any]) -> List[str]:
        """Generate usage examples for function"""
        return [f"{func.get('name')}()"]
    
    async def _generate_endpoint_description(self, endpoint: Dict[str, Any]) -> str:
        """Generate endpoint description"""
        return f"Handles {endpoint.get('method')} requests to {endpoint.get('path')}"
    
    async def _generate_response_schema(self, endpoint: Dict[str, Any]) -> Dict[str, Any]:
        """Generate response schema"""
        return {"type": "object", "properties": {"status": {"type": "string"}}}
    
    async def _generate_project_description(self, analysis: Dict[str, Any], context: Dict[str, Any]) -> str:
        """Generate project description"""
        return "AI-powered application with advanced features and intelligent automation"
    
    async def _generate_installation_instructions(self, context: Dict[str, Any]) -> str:
        """Generate installation instructions"""
        return "Standard installation process with dependency management"
    
    async def _generate_usage_instructions(self, analysis: Dict[str, Any]) -> str:
        """Generate usage instructions"""
        return "Follow the examples below to get started with the application"
    
    async def _format_parameters(self, parameters: List[Dict[str, Any]]) -> str:
        """Format parameters for documentation"""
        if not parameters:
            return "No parameters required"
        
        formatted = []
        for param in parameters:
            formatted.append(f"- `{param.get('name')}` ({param.get('type', 'string')}): {param.get('description', 'No description')}")
        
        return "\n".join(formatted)